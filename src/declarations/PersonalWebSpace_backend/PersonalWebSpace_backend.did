type UserRecord = 
 record {
   file_ids: vec text;
   totalSize: nat;
 };
type User = 
 variant {
   address: AccountIdentifier;
   "principal": principal;
 };
type UpdateMetadataValuesInput = 
 record {
   id: TokenId;
   updatedAboutDescription: text;
   updatedOwnerContactInfo: text;
   updatedOwnerName: text;
   updatedSpaceData: opt text;
   updatedSpaceDescription: text;
   updatedSpaceName: text;
 };
type TxReceipt = 
 variant {
   Err: ApiError;
   Ok: nat;
 };
type TransferResponse = 
 variant {
   err:
    variant {
      CannotNotify: AccountIdentifier;
      InsufficientBalance;
      InvalidToken: TokenIdentifier;
      Other: text;
      Rejected;
      Unauthorized: AccountIdentifier;
    };
   ok: Balance;
 };
type TransferRequest = 
 record {
   amount: Balance;
   from: User;
   memo: Memo;
   notify: bool;
   subaccount: opt SubAccount;
   to: User;
   token: TokenIdentifier;
 };
type TokenIndex = nat32;
type TokenIdentifier__1 = text;
type TokenIdentifier = text;
type TokenId = nat64;
type Time = int;
type SubAccount = vec nat8;
type StreamingStrategy = variant {
                           Callback:
                            record {
                              callback: StreamingCallback;
                              token: StreamingCallbackToken;
                            };};
type StreamingCallbackToken = 
 record {
   content_encoding: text;
   index: nat;
   key: text;
 };
type StreamingCallbackResponse = 
 record {
   body: blob;
   token: opt StreamingCallbackToken;
 };
type StreamingCallback = func (StreamingCallbackToken) ->
                          (StreamingCallbackResponse) query;
type SignUpFormInput = 
 record {
   emailAddress: text;
   pageSubmittedFrom: text;
 };
type Result_4 = 
 variant {
   err: CommonError;
   ok: AccountIdentifier__1;
 };
type Result_3 = 
 variant {
   err: CommonError;
   ok: ExtMetadata;
 };
type Result_2 = 
 variant {
   err: CommonError;
   ok: Balance__1;
 };
type Result_1 = 
 variant {
   err: CommonError;
   ok: vec TokenIndex;
 };
type Result = 
 variant {
   err: CommonError;
   ok: vec record {
             TokenIndex;
             opt EntrepotTypesListing;
             opt vec nat8;
           };
 };
type Response = 
 record {
   body: blob;
   headers: vec HeaderField;
   status_code: nat16;
   streaming_strategy: opt StreamingStrategy;
   upgrade: bool;
 };
type Request = 
 record {
   body: blob;
   headers: vec HeaderField;
   method: text;
   url: text;
 };
type PersonalWebSpace = 
 service {
   balance: (BalanceRequest) -> (BalanceResponse) query;
   balanceOfDip721: (principal) -> (nat64) query;
   bearer: (TokenIdentifier__1) -> (Result_4) query;
   check_user_has_nft: () -> (bool) query;
   createSpace: (text) -> (NftResult);
   deleteEmailSubscriber: (text) -> (bool);
   deleteFile: (text) -> (FileResult);
   extensions: () -> (vec Extension) query;
   getCallerSpaces: () -> (vec Nft) query;
   getEmailSubscribers: () -> (vec record {
                                     text;
                                     EmailSubscriber;
                                   });
   getFile: (text) -> (FileResult) query;
   getMaxLimitDip721: () -> (nat16) query;
   getMetadataDip721: (TokenId) -> (MetadataResult) query;
   getMetadataForUserDip721: (principal) -> (ExtendedMetadataResult);
   getRandomSpace: () -> (NftResult);
   getSpace: (TokenId) -> (NftResult) query;
   getTokenIdsForUserDip721: (principal) -> (vec TokenId) query;
   getUserRecord: () -> (FileResult);
   greet: (text) -> (text);
   hideUserSpace: (TokenId) -> (NftResult);
   http_request: (Request) -> (Response) query;
   listUserFileIds: () -> (FileResult) query;
   listUserFileIdsAndNames: () -> (FileResult) query;
   listUserFileNames: () -> (FileResult) query;
   logoDip721: () -> (LogoResult) query;
   metadata: (TokenIdentifier__1) -> (Result_3) query;
   mintDip721: (principal, MetadataDesc) -> (MintReceipt);
   mintNFT: (ExtMintRequest) -> ();
   nameDip721: () -> (text) query;
   ownerOfDip721: (TokenId) -> (OwnerResult) query;
   safeTransferFromDip721: (principal, principal, TokenId) -> (TxReceipt);
   submitSignUpForm: (SignUpFormInput) -> (text);
   supply: (TokenIdentifier__1) -> (Result_2) query;
   supportedInterfacesDip721: () -> (vec InterfaceId) query;
   symbolDip721: () -> (text) query;
   tokens: (AccountIdentifier__1) -> (Result_1) query;
   tokens_ext: (AccountIdentifier__1) -> (Result) query;
   totalSupplyDip721: () -> (nat64) query;
   transfer: (TransferRequest) -> (TransferResponse);
   transferFromDip721: (principal, principal, TokenId) -> (TxReceipt);
   updateSpaceEntityId: (TokenId, text) -> (NftResult);
   updateUserSpace: (UpdateMetadataValuesInput) -> (NftResult);
   uploadUserFile: (text, File) -> (FileResult);
 };
type OwnerResult = 
 variant {
   Err: ApiError;
   Ok: principal;
 };
type NftResult = 
 variant {
   Err: ApiError;
   Ok: Nft;
 };
type Nft = 
 record {
   id: TokenId;
   metadata: MetadataDesc;
   owner: principal;
 };
type MintReceiptPart = 
 record {
   id: nat;
   token_id: TokenId;
 };
type MintReceipt = 
 variant {
   Err: ApiError;
   Ok: MintReceiptPart;
 };
type MetadataVal = 
 variant {
   BlobContent: blob;
   Nat16Content: nat16;
   Nat32Content: nat32;
   Nat64Content: nat64;
   Nat8Content: nat8;
   NatContent: nat;
   PrincipalContent: principal;
   TextArrayContent: vec text;
   TextContent: text;
   TextToTextAssocListContent: AssocList;
 };
type MetadataResult = 
 variant {
   Err: ApiError;
   Ok: MetadataDesc;
 };
type MetadataPurpose = 
 variant {
   Preview;
   Rendered;
 };
type MetadataPart = 
 record {
   data: blob;
   key_val_data: vec MetadataKeyVal;
   purpose: MetadataPurpose;
 };
type MetadataKeyVal = 
 record {
   key: text;
   val: MetadataVal;
 };
type MetadataDesc = vec MetadataPart;
type Memo = blob;
type LogoResult = 
 record {
   data: text;
   logo_type: text;
 };
type List = 
 opt record {
       record {
         text;
         text;
       };
       List;
     };
type InterfaceId = 
 variant {
   Approval;
   Burn;
   Mint;
   TransactionHistory;
   TransferNotification;
 };
type HeaderField = 
 record {
   text;
   text;
 };
type FileResultSuccessOptions = 
 variant {
   File: FileInfo;
   FileId: text;
   FileIds: vec text;
   FileIdsAndNames: vec FileIdAndName;
   FileNames: vec text;
   Other: text;
   Success;
   UserRecord: UserRecord;
 };
type FileResult = 
 variant {
   Err: ApiError;
   Ok: FileResultSuccessOptions;
 };
type FileInfo = 
 record {
   file_content: blob;
   file_name: text;
   owner_principal: text;
 };
type FileIdAndName = 
 record {
   file_id: text;
   file_name: text;
 };
type File = blob;
type Extension = text;
type ExtendedMetadataResult = 
 variant {
   Err: ApiError;
   Ok: record {
         metadata_desc: MetadataDesc;
         token_id: TokenId;
       };
 };
type ExtMintRequest = 
 record {
   metadata: opt blob;
   to: User;
 };
type ExtMetadata = 
 variant {
   fungible:
    record {
      decimals: nat8;
      metadata: opt blob;
      name: text;
      symbol: text;
    };
   nonfungible: record {metadata: opt blob;};
 };
type EntrepotTypesListing = 
 record {
   locked: opt Time;
   price: nat64;
   seller: principal;
   subaccount: opt SubAccount;
 };
type EmailSubscriber = 
 record {
   emailAddress: text;
   pageSubmittedFrom: text;
   subscribedAt: nat64;
 };
type Dip721NonFungibleToken = 
 record {
   logo: LogoResult;
   maxLimit: nat16;
   name: text;
   symbol: text;
 };
type CommonError__1 = 
 variant {
   InvalidToken: TokenIdentifier;
   Other: text;
 };
type CommonError = 
 variant {
   InvalidToken: TokenIdentifier;
   Other: text;
 };
type Balance__1 = nat;
type BalanceResponse = 
 variant {
   err: CommonError__1;
   ok: Balance;
 };
type BalanceRequest = 
 record {
   token: TokenIdentifier;
   user: User;
 };
type Balance = nat;
type AssocList = 
 opt record {
       record {
         text;
         text;
       };
       List;
     };
type ApiError = 
 variant {
   InvalidTokenId;
   Other: text;
   Unauthorized;
   ZeroAddress;
 };
type AccountIdentifier__1 = text;
type AccountIdentifier = text;
service : (principal, Dip721NonFungibleToken) -> PersonalWebSpace
